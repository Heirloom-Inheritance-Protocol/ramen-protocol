/**
 * @module @semaphore-protocol/data
 * @version 4.14.0
 * @file A library for querying Semaphore smart contract.
 * @copyright Ethereum Foundation 2025
 * @license MIT
 * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/data}
*/
'use strict';

var networks = require('@semaphore-protocol/utils/networks');
var constants$1 = require('ethers/constants');
var contract = require('ethers/contract');
var providers = require('ethers/providers');
var constants = require('@semaphore-protocol/utils/constants');
var errorHandlers = require('@zk-kit/utils/error-handlers');
var axios = require('axios');
var viem = require('viem');

/**
 * Fetches a list of blockchain events from a smart contract based on specified filters and starting block.
 * @param contract An instance of an ethers Contract connected to the blockchain.
 * @param eventName The name of the event to filter.
 * @param filterArgs Optional arguments to further filter the events.
 * @param startBlock The block number from which to start fetching events (defaults to 0).
 * @returns A promise that resolves to an array of event logs, each including event arguments and the block number.
 */
async function getEvents(contract, eventName, filterArgs = [], startBlock = 0) {
    const filter = contract.filters[eventName](...filterArgs);
    const events = (await contract.queryFilter(filter, startBlock));
    return events.map(({ args, blockNumber }) => [...args, blockNumber]);
}

/**
 * The SemaphoreEthers class provides a high-level interface to interact with the Semaphore smart contract
 * using the {@link https://docs.ethers.org/v5/ | ethers.js} library. It encapsulates all necessary functionalities to connect to Ethereum networks,
 * manage contract instances, and perform operations such as retrieving group information or checking group memberships.
 * This class simplifies the interaction with the Ethereum blockchain by abstracting the details of network connections
 * and contract interactions.
 */
class SemaphoreEthers {
    /**
     * Constructs a new SemaphoreEthers instance, initializing it with a network or a custom Ethereum node URL,
     * and optional configuration settings for the ethers provider and contract.
     * @param networkOrEthereumURL The Ethereum network name or a custom JSON-RPC URL to connect to.
     * @param options Configuration options for the ethers provider and the Semaphore contract.
     */
    constructor(networkOrEthereumURL = networks.defaultNetwork, options = {}) {
        errorHandlers.requireString(networkOrEthereumURL, "networkOrEthereumURL");
        if (options.provider) {
            errorHandlers.requireString(options.provider, "provider");
        }
        else if (!networkOrEthereumURL.startsWith("http")) {
            options.provider = "infura";
        }
        if (options.apiKey) {
            errorHandlers.requireString(options.apiKey, "apiKey");
        }
        if (networks.isSupportedNetwork(networkOrEthereumURL)) {
            const { address, startBlock } = networks.getDeployedContract(networkOrEthereumURL);
            options.address ?? (options.address = address);
            options.startBlock ?? (options.startBlock = startBlock);
        }
        else {
            options.startBlock ?? (options.startBlock = 0);
        }
        if (options.address === undefined) {
            throw new Error(`Network '${networkOrEthereumURL}' needs a Semaphore contract address`);
        }
        let provider;
        switch (options.provider) {
            case "infura":
                provider = new providers.InfuraProvider(networkOrEthereumURL, options.projectId, options.projectSecret);
                break;
            case "alchemy":
                provider = new providers.AlchemyProvider(networkOrEthereumURL, options.apiKey);
                break;
            case "cloudflare":
                provider = new providers.CloudflareProvider(networkOrEthereumURL);
                break;
            case "etherscan":
                provider = new providers.EtherscanProvider(networkOrEthereumURL, options.apiKey);
                break;
            case "pocket":
                provider = new providers.PocketProvider(networkOrEthereumURL, options.applicationId, options.applicationSecret);
                break;
            case "ankr":
                provider = new providers.AnkrProvider(networkOrEthereumURL, options.apiKey);
                break;
            default:
                if (!networkOrEthereumURL.startsWith("http")) {
                    throw new Error(`Provider '${options.provider}' is not supported`);
                }
                provider = new providers.JsonRpcProvider(networkOrEthereumURL);
        }
        this._network = networkOrEthereumURL;
        this._options = options;
        this._contract = new contract.Contract(options.address, constants.SemaphoreABI, provider);
    }
    /**
     * Retrieves the Ethereum network or custom URL currently used by this instance.
     * @returns The network or URL as a string.
     */
    get network() {
        return this._network;
    }
    /**
     * Retrieves the options used for configuring the ethers provider and the Semaphore contract.
     * @returns The configuration options.
     */
    get options() {
        return this._options;
    }
    /**
     * Retrieves the ethers Contract instance used to interact with the Semaphore contract.
     * @returns The Contract instance.
     */
    get contract() {
        return this._contract;
    }
    /**
     * Fetches the list of group IDs from the Semaphore contract by querying the "GroupCreated" events.
     * @returns A promise that resolves to an array of group IDs as strings.
     */
    async getGroupIds() {
        const groups = await getEvents(this._contract, "GroupCreated", [], this._options.startBlock);
        return groups.map((event) => event[0].toString());
    }
    /**
     * Retrieves detailed information about a specific group by its ID. This method queries the Semaphore contract
     * to get the group's admin, Merkle tree root, depth, and size.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to a GroupResponse object.
     */
    async getGroup(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === constants$1.ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const merkleTreeRoot = await this._contract.getMerkleTreeRoot(groupId);
        const merkleTreeDepth = await this._contract.getMerkleTreeDepth(groupId);
        const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
        const group = {
            id: groupId,
            admin: groupAdmin,
            merkleTree: {
                depth: Number(merkleTreeDepth),
                size: Number(merkleTreeSize),
                root: merkleTreeRoot.toString()
            }
        };
        return group;
    }
    /**
     * Fetches a list of members from a specific group. This method queries the Semaphore contract for events
     * related to member additions and updates, and constructs the list of current group members.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of member identity commitments as strings.
     */
    async getGroupMembers(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === constants$1.ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const memberRemovedEvents = await getEvents(this._contract, "MemberRemoved", [groupId], this._options.startBlock);
        const memberUpdatedEvents = await getEvents(this._contract, "MemberUpdated", [groupId], this._options.startBlock);
        const memberUpdatedEventsMap = new Map();
        for (const [, index, , newIdentityCommitment, , blockNumber] of memberUpdatedEvents) {
            memberUpdatedEventsMap.set(index.toString(), [blockNumber, newIdentityCommitment.toString()]);
        }
        for (const [, index, , , blockNumber] of memberRemovedEvents) {
            const groupUpdate = memberUpdatedEventsMap.get(index.toString());
            if (!groupUpdate || (groupUpdate && groupUpdate[0] < blockNumber)) {
                memberUpdatedEventsMap.set(index.toString(), [blockNumber, "0"]);
            }
        }
        const membersAddedEvents = await getEvents(this._contract, "MembersAdded", [groupId], this._options.startBlock);
        const membersAddedEventsMap = new Map();
        for (const [, startIndex, identityCommitments] of membersAddedEvents) {
            membersAddedEventsMap.set(startIndex.toString(), identityCommitments.map((i) => i.toString()));
        }
        const memberAddedEvents = await getEvents(this._contract, "MemberAdded", [groupId], this._options.startBlock);
        const members = [];
        const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
        let i = 0;
        while (i < Number(merkleTreeSize)) {
            const identityCommitments = membersAddedEventsMap.get(i.toString());
            if (identityCommitments) {
                members.push(...identityCommitments);
                i += identityCommitments.length;
            }
            else {
                members.push(memberAddedEvents[i][2]);
                i += 1;
            }
        }
        for (let j = 0; j < members.length; j += 1) {
            const groupUpdate = memberUpdatedEventsMap.get(j.toString());
            if (groupUpdate) {
                members[j] = groupUpdate[1].toString();
            }
        }
        return members;
    }
    /**
     * Retrieves a list of validated proofs for a specific group. This method queries the Semaphore contract
     * for "ProofValidated" events and returns details about each proof.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of validated proofs.
     */
    async getGroupValidatedProofs(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === constants$1.ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const proofValidatedEvents = await getEvents(this._contract, "ProofValidated", [groupId], this._options.startBlock);
        return proofValidatedEvents.map((event) => ({
            merkleTreeDepth: Number(event[1]),
            merkleTreeRoot: event[2].toString(),
            nullifier: event[3].toString(),
            message: event[4].toString(),
            scope: event[5].toString(),
            points: event[6].map((p) => p.toString())
        }));
    }
    /**
     * Checks whether a specific member is part of a group. This method queries the Semaphore contract
     * to determine if the provided identity commitment is a member of the specified group.
     * @param groupId The unique identifier of the group.
     * @param member The identity commitment of the member to check.
     * @returns A promise that resolves to true if the member is part of the group, otherwise false.
     */
    async isGroupMember(groupId, member) {
        errorHandlers.requireString(groupId, "groupId");
        errorHandlers.requireString(member, "member");
        return this._contract.hasMember(groupId, member);
    }
    /**
     * Listens to the GroupCreated event.
     * @param callback Called with the groupId of the newly created group.
     */
    onGroupCreated(callback) {
        this._contract.on("GroupCreated", (groupId, event) => {
            callback(groupId.toString(), event);
        });
    }
    /**
     * Removes all listeners for the GroupCreated event.
     * Stop receiving group creation notifications.
     */
    offGropupCreated() {
        this._contract.removeAllListeners("GroupCreated");
    }
    /**
     * Listens to MemberAdded events.
     * @param callback Receives the groupId, identityCommitment and event metadata.
     */
    onMemberAdded(callback) {
        this._contract.on("MemberAdded", (groupId, _index, identityCommitment, merkleTreeRoot, event) => {
            callback(groupId.toString(), identityCommitment.toString(), merkleTreeRoot.toString(), event);
        });
    }
    /**
     * Removes all listeners for the MemberAdded event.
     * Stop tracking when new members are added.
     */
    offMemberAdded() {
        this._contract.removeAllListeners("MemberAdded");
    }
    /**
     * Listens to MemberUpdated events.
     * @param callback Receives the groupId, old identityCommitment, new identityCommitment, and event metadata.
     */
    onMemberUpdated(callback) {
        this._contract.on("MemberUpdated", (groupId, _index, oldIdentityCommitment, newIdentityCommitment, merkleTreeRoot, event) => {
            callback(groupId.toString(), oldIdentityCommitment.toString(), newIdentityCommitment.toString(), merkleTreeRoot.toString(), event);
        });
    }
    /**
     * Removes all listeners for the MemberUpdated event.
     * Stop receiving updates when members change their commitment.
     */
    offMemberUpdated() {
        this._contract.removeAllListeners("MemberUpdated");
    }
    /**
     * Listens to MemberRemoved events.
     * @param callback Receives the groupId, identityCommitment and event metadata.
     */
    onMemberRemoved(callback) {
        this._contract.on("MemberRemoved", (groupId, _index, identityCommitment, merkleTreeRoot, event) => {
            callback(groupId.toString(), identityCommitment.toString(), merkleTreeRoot.toString(), event);
        });
    }
    /**
     * Removes all listeners for the MemberRemoved event.
     * Stop listening for member removals.
     */
    offMemberRemoved() {
        this._contract.removeAllListeners("MemberRemoved");
    }
    /**
     * Listens to the ProofValidated event.
     * @param callback Called with proof parameters and event metadata.
     */
    onProofValidated(callback) {
        this._contract.on("ProofValidated", (groupId, merkleTreeDepth, merkleTreeRoot, nullifier, message, scope, points, event) => {
            callback({
                groupId: groupId.toString(),
                merkleTreeDepth: Number(merkleTreeDepth),
                merkleTreeRoot: merkleTreeRoot.toString(),
                nullifier: nullifier.toString(),
                message: message.toString(),
                scope: scope.toString(),
                points: points.map((p) => p.toString()),
                event
            });
        });
    }
    /**
     * Removes all listeners for the ProofValidated event.
     * Stop receiving proof validation notifications.
     */
    offProofValidated() {
        this._contract.removeAllListeners("ProofValidated");
    }
    /**
     * Listens to the GroupAdminUpdated event.
     * @param callback Receives the groupId, old admin and new admin addresses and event metadata.
     */
    onGroupAdminUpdated(callback) {
        this._contract.on("GroupAdminUpdated", (groupId, oldAdmin, newAdmin, event) => {
            callback(groupId.toString(), oldAdmin.toString(), newAdmin.toString(), event);
        });
    }
    /**
     * Removes all listeners for the GroupAdminUpdated event.
     * Stop tracking when a group's admin is updated.
     */
    offGroupAdminUpdated() {
        this._contract.removeAllListeners("GroupAdminUpdated");
    }
}

/**
 * Returns the subgraph URL related to the network passed as a parameter.
 * This function retrieves the URL of the Semaphore subgraph based on the provided network.
 * @param supportedNetwork Semaphore supported network.
 * @returns Subgraph URL.
 */
function getURL(supportedNetwork) {
    if (!networks.isSupportedNetwork(supportedNetwork)) {
        throw new TypeError(`Network '${supportedNetwork}' is not supported`);
    }
    return `https://api.studio.thegraph.com/query/14377/semaphore-${supportedNetwork}/v4.5.0`;
}

/**
 * Sends an HTTP request to a specified URL and returns the parsed response data.
 * @param url The URL to which the HTTP request is sent.
 * @param config Optional Axios request configuration to customize headers, method, timeout, etc.
 * @returns A promise that resolves to the data extracted from the response, typically in JSON format.
 */
/* istanbul ignore next */
async function request(url, config) {
    const { data } = await axios(url, {
        headers: {
            "Content-Type": "application/json",
            ...config?.headers
        },
        ...config
    });
    return data?.data;
}

/**
 * Converts a JavaScript Date object into a Unix timestamp.
 * @param date The Date object to convert.
 * @returns The Unix timestamp equivalent of the provided Date object.
 */
// eslint-disable-next-line import/prefer-default-export
function jsDateToGraphqlDate(date) {
    return Math.round(date.getTime() / 1000);
}

/**
 * The SemaphoreSubgraph class provides an interface to interact with the Semaphore smart contract
 * via subgraph queries. It enables operations such as retrieving lists of group members and validated proofs,
 * as well as checking membership within groups.
 * Each group in Semaphore is represented as a {@link https://zkkit.pse.dev/classes/_zk_kit_lean_imt.LeanIMT.html | LeanIMT}
 * (Lean Incremental Merkle Tree). This class supports interaction through either a
 * {@link SupportedNetwork} or a direct URL to the subgraph. The subgraphs themselves are hosted on
 * {@link https://thegraph.com/ | The Graph} protocol, facilitating efficient and decentralized query processing.
 */
class SemaphoreSubgraph {
    /**
     * Initializes the SemaphoreSubgraph instance with a supported network or a custom subgraph URL.
     * This allows to interact with the Semaphore smart contract through the specified endpoint.
     * @param networkOrSubgraphURL Either a supported network identifier or a direct URL to the subgraph.
     */
    constructor(networkOrSubgraphURL = networks.defaultNetwork) {
        errorHandlers.requireString(networkOrSubgraphURL, "networkOrSubgraphURL");
        if (typeof networkOrSubgraphURL === "string" && networkOrSubgraphURL.startsWith("http")) {
            this._url = networkOrSubgraphURL;
            return;
        }
        this._url = getURL(networkOrSubgraphURL);
    }
    /**
     * Retrieves the URL of the subgraph currently being used by the instance.
     * This URL points to the specific subgraph where Semaphore data is stored.
     * @returns The URL of the subgraph.
     */
    get url() {
        return this._url;
    }
    /**
     * Fetches a list of all group IDs from the subgraph. This method queries the subgraph to retrieve
     * identifiers for all groups managed by the Semaphore smart contract.
     * @returns A promise that resolves to an array of group IDs.
     */
    async getGroupIds() {
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups {
                        id
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        return groups.map((group) => group.id);
    }
    /**
     * Retrieves detailed information about groups from the subgraph based on the provided options.
     * This method can filter groups by various parameters and include additional details like members
     * and validated proofs if specified in the options.
     * @param options Configuration options to filter groups and specify which additional details to fetch.
     * @returns A promise that resolves to an array of group details.
     */
    async getGroups(options = {}) {
        errorHandlers.requireObject(options, "options");
        const { members = false, validatedProofs = false } = options;
        errorHandlers.requireBoolean(members, "members");
        errorHandlers.requireBoolean(validatedProofs, "validatedProofs");
        let filtersQuery = "";
        if (options.filters) {
            const { admin, identityCommitment, timestamp, timestampGte, timestampLte } = options.filters;
            const filterFragments = [];
            if (admin) {
                filterFragments.push(`admin: "${admin}"`);
            }
            if (identityCommitment) {
                filterFragments.push(`members_: { identityCommitment: "${identityCommitment}" }`);
            }
            /* istanbul ignore next */
            if (timestamp) {
                filterFragments.push(`timestamp: "${jsDateToGraphqlDate(timestamp)}"`);
            }
            else if (timestampGte) {
                filterFragments.push(`timestamp_gte: "${jsDateToGraphqlDate(timestampGte)}"`);
            }
            else if (timestampLte) {
                filterFragments.push(`timestamp_lte: "${jsDateToGraphqlDate(timestampLte)}"`);
            }
            if (filterFragments.length > 0) {
                filtersQuery = `(where: {${filterFragments.join(", ")}})`;
            }
        }
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups ${filtersQuery} {
                        id
                        merkleTree {
                            root
                            depth
                            size
                        }
                        admin
                        ${members === true
                    ? `members(orderBy: index) {
                            identityCommitment
                        }`
                    : ""}
                        ${validatedProofs === true
                    ? `validatedProofs(orderBy: timestamp) {
                            message
                            merkleTreeRoot
                            merkleTreeDepth
                            scope
                            nullifier
                            points
                            timestamp
                        }`
                    : ""}
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        if (groups && members) {
            for (const group of groups) {
                group.members = group.members.map((member) => member.identityCommitment);
            }
        }
        return groups;
    }
    /**
     * Fetches detailed information about a specific group by its ID. This method can also retrieve
     * members and validated proofs for the group if requested via options.
     * @param groupId The unique identifier of the group.
     * @param options Configuration options to specify which details to fetch about the group.
     * @returns A promise that resolves to the details of the specified group.
     */
    async getGroup(groupId, options = {}) {
        errorHandlers.requireString(groupId, "groupId");
        errorHandlers.requireObject(options, "options");
        const { members = false, validatedProofs = false } = options;
        errorHandlers.requireBoolean(members, "members");
        errorHandlers.requireBoolean(validatedProofs, "validatedProofs");
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups(where: { id: "${groupId}" }) {
                        id
                        merkleTree {
                            root
                            depth
                            size
                        }
                        admin
                        ${members === true
                    ? `members(orderBy: index) {
                            identityCommitment
                        }`
                    : ""}
                        ${validatedProofs === true
                    ? `validatedProofs(orderBy: timestamp) {
                            message
                            merkleTreeRoot
                            merkleTreeDepth
                            scope
                            nullifier
                            points
                            timestamp
                        }`
                    : ""}
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        if (groups && members) {
            groups[0].members = groups[0].members.map((member) => member.identityCommitment);
        }
        return groups[0];
    }
    /**
     * Retrieves a list of members from a specific group.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of group members' identity commitments.
     */
    async getGroupMembers(groupId) {
        const group = await this.getGroup(groupId, { members: true }); // parameters are checked inside getGroup
        return group.members;
    }
    /**
     * Fetches a list of validated proofs for a specific group.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of validated proofs.
     */
    async getGroupValidatedProofs(groupId) {
        const group = await this.getGroup(groupId, { validatedProofs: true }); // parameters are checked inside getGroup
        return group.validatedProofs;
    }
    /**
     * Determines whether a specific member is part of a group. This method queries the subgraph to check
     * if the provided member's identity commitment exists within the specified group.
     * @param groupId The unique identifier of the group.
     * @param member The identity commitment of the member to check.
     * @returns A promise that resolves to true if the member is part of the group, otherwise false.
     */
    async isGroupMember(groupId, member) {
        errorHandlers.requireString(groupId, "groupId");
        errorHandlers.requireString(member, "member");
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups(where: { id: "${groupId}", members_: { identityCommitment: "${member}" } }) {
                        id
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        return groups.length !== 0;
    }
}

/**
 * The SemaphoreViem class provides a high-level interface to interact with the Semaphore smart contract
 * using the {@link https://viem.sh | viem} library. It encapsulates all necessary functionalities to connect to Ethereum networks,
 * manage contract instances, and perform operations such as retrieving group information or checking group memberships.
 * This class simplifies the interaction with the Ethereum blockchain by abstracting the details of network connections
 * and contract interactions.
 */
class SemaphoreViem {
    /**
     * Constructs a new SemaphoreViem instance, initializing it with a network or a custom Ethereum node URL,
     * and optional configuration settings for the viem client and contract.
     * @param networkOrEthereumURL The Ethereum network name or a custom JSON-RPC URL to connect to.
     * @param options Configuration options for the viem client and the Semaphore contract.
     */
    constructor(networkOrEthereumURL = networks.defaultNetwork, options = {}) {
        errorHandlers.requireString(networkOrEthereumURL, "networkOrEthereumURL");
        if (options.apiKey) {
            errorHandlers.requireString(options.apiKey, "apiKey");
        }
        if (networks.isSupportedNetwork(networkOrEthereumURL)) {
            const { address, startBlock } = networks.getDeployedContract(networkOrEthereumURL);
            options.address ?? (options.address = address);
            options.startBlock ?? (options.startBlock = BigInt(startBlock));
        }
        else {
            options.startBlock ?? (options.startBlock = 0n);
        }
        if (options.address === undefined) {
            throw new Error(`Network '${networkOrEthereumURL}' needs a Semaphore contract address`);
        }
        let transport;
        if (options.transport) {
            transport = options.transport;
        }
        else if (!networkOrEthereumURL.startsWith("http")) {
            transport = viem.http();
        }
        else {
            transport = viem.http(networkOrEthereumURL);
        }
        this._network = networkOrEthereumURL;
        this._options = options;
        // Create the public client
        this._client =
            options.publicClient ??
                viem.createPublicClient({
                    transport,
                    chain: options.chain
                });
        // Create the contract instance
        this._contract = viem.getContract({
            address: options.address,
            abi: constants.SemaphoreABI,
            client: this._client
        });
    }
    /**
     * Retrieves the Ethereum network or custom URL currently used by this instance.
     * @returns The network or URL as a string.
     */
    get network() {
        return this._network;
    }
    /**
     * Retrieves the options used for configuring the viem client and the Semaphore contract.
     * @returns The configuration options.
     */
    get options() {
        return this._options;
    }
    /**
     * Retrieves the viem Contract instance used to interact with the Semaphore contract.
     * @returns The Contract instance.
     */
    get contract() {
        return this._contract;
    }
    /**
     * Retrieves the viem Public Client instance used to interact with the blockchain.
     * @returns The Public Client instance.
     */
    get client() {
        return this._client;
    }
    /**
     * Fetches the list of group IDs from the Semaphore contract by querying the "GroupCreated" events.
     * @returns A promise that resolves to an array of group IDs as strings.
     */
    async getGroupIds() {
        const logs = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "GroupCreated",
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        return logs.map((log) => log.args.groupId.toString());
    }
    /**
     * Retrieves detailed information about a specific group by its ID. This method queries the Semaphore contract
     * to get the group's admin, Merkle tree root, depth, and size.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to a GroupResponse object.
     */
    async getGroup(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.read.getGroupAdmin([groupId]);
        if (groupAdmin === viem.zeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const merkleTreeRoot = await this._contract.read.getMerkleTreeRoot([groupId]);
        const merkleTreeDepth = await this._contract.read.getMerkleTreeDepth([groupId]);
        const merkleTreeSize = await this._contract.read.getMerkleTreeSize([groupId]);
        const group = {
            id: groupId,
            admin: groupAdmin,
            merkleTree: {
                depth: Number(merkleTreeDepth),
                size: Number(merkleTreeSize),
                root: merkleTreeRoot ? merkleTreeRoot.toString() : ""
            }
        };
        return group;
    }
    /**
     * Fetches a list of members from a specific group. This method queries the Semaphore contract for events
     * related to member additions and updates, and constructs the list of current group members.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of member identity commitments as strings.
     */
    async getGroupMembers(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.read.getGroupAdmin([groupId]);
        if (groupAdmin === viem.zeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        // Get member removed events
        const memberRemovedEvents = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "MemberRemoved",
            args: {
                groupId: BigInt(groupId)
            },
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        // Get member updated events
        const memberUpdatedEvents = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "MemberUpdated",
            args: {
                groupId: BigInt(groupId)
            },
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        const memberUpdatedEventsMap = new Map();
        for (const event of memberUpdatedEvents) {
            if (event.args.index && event.args.newIdentityCommitment && event.blockNumber) {
                memberUpdatedEventsMap.set(event.args.index.toString(), [
                    event.blockNumber,
                    event.args.newIdentityCommitment.toString()
                ]);
            }
        }
        for (const event of memberRemovedEvents) {
            if (event.args.index && event.blockNumber) {
                const groupUpdate = memberUpdatedEventsMap.get(event.args.index.toString());
                if (!groupUpdate || (groupUpdate && groupUpdate[0] < event.blockNumber)) {
                    memberUpdatedEventsMap.set(event.args.index.toString(), [event.blockNumber, "0"]);
                }
            }
        }
        // Get members added events (batch additions)
        const membersAddedEvents = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "MembersAdded",
            args: {
                groupId: BigInt(groupId)
            },
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        const membersAddedEventsMap = new Map();
        for (const event of membersAddedEvents) {
            if (event.args.startIndex && event.args.identityCommitments) {
                membersAddedEventsMap.set(event.args.startIndex.toString(), event.args.identityCommitments.map((i) => i.toString()));
            }
        }
        // Get individual member added events
        const memberAddedEvents = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "MemberAdded",
            args: {
                groupId: BigInt(groupId)
            },
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        const members = [];
        const merkleTreeSize = await this._contract.read.getMerkleTreeSize([groupId]);
        let index = 0;
        while (index < Number(merkleTreeSize)) {
            const identityCommitments = membersAddedEventsMap.get(index.toString());
            if (identityCommitments) {
                members.push(...identityCommitments);
                index += identityCommitments.length;
            }
            else {
                const currentIndex = index; // Create a closure to capture the current index value
                const event = memberAddedEvents.find((e) => Number(e.args.index) === currentIndex);
                if (event && event.args.identityCommitment) {
                    members.push(event.args.identityCommitment.toString());
                }
                index += 1;
            }
        }
        // Apply updates to members
        for (let j = 0; j < members.length; j += 1) {
            const groupUpdate = memberUpdatedEventsMap.get(j.toString());
            if (groupUpdate) {
                members[j] = groupUpdate[1].toString();
            }
        }
        return members;
    }
    /**
     * Fetches a list of validated proofs for a specific group. This method queries the Semaphore contract for events
     * related to proof verification.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of validated proofs.
     */
    async getGroupValidatedProofs(groupId) {
        errorHandlers.requireString(groupId, "groupId");
        const groupAdmin = await this._contract.read.getGroupAdmin([groupId]);
        if (groupAdmin === viem.zeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const proofValidatedEvents = (await this._client.getContractEvents({
            address: this._options.address,
            abi: constants.SemaphoreABI,
            eventName: "ProofValidated",
            args: {
                groupId: BigInt(groupId)
            },
            fromBlock: BigInt(this._options.startBlock || 0)
        }));
        return proofValidatedEvents.map((event) => ({
            message: event.args.message?.toString() || "",
            merkleTreeRoot: event.args.merkleTreeRoot?.toString() || "",
            merkleTreeDepth: event.args.merkleTreeDepth?.toString() || "",
            scope: event.args.scope?.toString() || "",
            nullifier: event.args.nullifier?.toString() || "",
            points: [event.args.x?.toString() || "", event.args.y?.toString() || ""],
            timestamp: event.blockNumber ? new Date(Number(event.blockNumber) * 1000).toISOString() : undefined
        }));
    }
    /**
     * Checks if a given identity commitment is a member of a specific group.
     * @param groupId The unique identifier of the group.
     * @param member The identity commitment to check.
     * @returns A promise that resolves to a boolean indicating whether the member is in the group.
     */
    async isGroupMember(groupId, member) {
        errorHandlers.requireString(groupId, "groupId");
        errorHandlers.requireString(member, "member");
        const members = await this.getGroupMembers(groupId);
        return members.includes(member);
    }
}

exports.SemaphoreEthers = SemaphoreEthers;
exports.SemaphoreSubgraph = SemaphoreSubgraph;
exports.SemaphoreViem = SemaphoreViem;
